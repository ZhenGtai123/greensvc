{
  "permissions": {
    "allow": [
      "Bash(npm run dev:*)",
      "WebFetch(domain:)",
      "Bash(ls:*)",
      "Bash(python3:*)",
      "Bash(cat:*)",
      "Bash(/d/mini-conda/python:*)",
      "Bash(python:*)",
      "Bash(cd \"D:/green-svc/greensvc/packages/backend\" && PYTHONIOENCODING=utf-8 python << 'PYEOF'\nimport json, os, sys, tempfile, io\nsys.stdout = io.TextIOWrapper\\(sys.stdout.buffer, encoding=\"utf-8\", errors=\"replace\"\\)\n\nimport numpy as np\nfrom PIL import Image\n\n# Load semantic config\nwith open\\(\"data/Semantic_configuration.json\", \"r\", encoding=\"utf-8\"\\) as f:\n    config = json.load\\(f\\)\n\nsemantic_colors = {}\nfor item in config:\n    name = item[\"name\"]\n    hex_color = item[\"color\"].lstrip\\(\"#\"\\)\n    rgb = tuple\\(int\\(hex_color[i:i+2], 16\\) for i in \\(0, 2, 4\\)\\)\n    semantic_colors[name] = rgb\n\nprint\\(f\"Loaded {len\\(semantic_colors\\)} semantic classes\"\\)\n\n# ===================================================================\n# TEST 1: VPE Calculator\n# ===================================================================\nprint\\(\"\\\\n\" + \"=\" * 60\\)\nprint\\(\"TEST 1: IND_VPE \\(Vegetation Permeability Index\\)\"\\)\nprint\\(\"=\" * 60\\)\n\nvpe_globals = {\"semantic_colors\": semantic_colors, \"__name__\": \"test\"}\nexec\\(open\\(\"data/metrics_code/calculator_layer_IND_VPE.py\", encoding=\"utf-8\"\\).read\\(\\), vpe_globals\\)\n\ncalculate_vpe = vpe_globals[\"calculate_indicator\"]\nINDICATOR_VPE = vpe_globals[\"INDICATOR\"]\nTARGET_RGB_VPE = vpe_globals[\"TARGET_RGB\"]\n\nprint\\(f\"\\\\nINDICATOR id: {INDICATOR_VPE['id']}\"\\)\nprint\\(f\"TARGET_RGB matched: {len\\(TARGET_RGB_VPE\\)} classes\"\\)\n\n# Test: 30% grass + 20% tree = 50% veg => VPE = 50%\ntest_img = np.zeros\\(\\(100, 100, 3\\), dtype=np.uint8\\)\ntest_img[0:30, 0:100] = semantic_colors[\"grass\"]\ntest_img[30:50, 0:100] = semantic_colors[\"tree\"]\n\ntmp = os.path.join\\(tempfile.gettempdir\\(\\), \"test_vpe.png\"\\)\nImage.fromarray\\(test_img\\).save\\(tmp\\)\nresult = calculate_vpe\\(tmp\\)\nprint\\(f\"\\\\nTest: 30% grass + 20% tree + 50% other\"\\)\nprint\\(f\"Expected VPE: 50.0%, Got: {result['value']}\"\\)\nassert result[\"success\"] and abs\\(result[\"value\"] - 50.0\\) < 0.1\nprint\\(\"PASS!\"\\)\n\n# 100% vegetation => VPE = 0%\ntest_img2 = np.full\\(\\(100, 100, 3\\), semantic_colors[\"grass\"], dtype=np.uint8\\)\ntmp2 = os.path.join\\(tempfile.gettempdir\\(\\), \"test_vpe2.png\"\\)\nImage.fromarray\\(test_img2\\).save\\(tmp2\\)\nr2 = calculate_vpe\\(tmp2\\)\nprint\\(f\"\\\\n100% vegetation => Expected VPE: 0.0%, Got: {r2['value']}\"\\)\nassert abs\\(r2[\"value\"] - 0.0\\) < 0.1\nprint\\(\"PASS!\"\\)\n\n# 0% vegetation => VPE = 100%\ntest_img3 = np.zeros\\(\\(100, 100, 3\\), dtype=np.uint8\\)\ntmp3 = os.path.join\\(tempfile.gettempdir\\(\\), \"test_vpe3.png\"\\)\nImage.fromarray\\(test_img3\\).save\\(tmp3\\)\nr3 = calculate_vpe\\(tmp3\\)\nprint\\(f\"\\\\n0% vegetation => Expected VPE: 100.0%, Got: {r3['value']}\"\\)\nassert abs\\(r3[\"value\"] - 100.0\\) < 0.1\nprint\\(\"PASS!\"\\)\n\n# Class breakdown check\nprint\\(f\"\\\\nClass breakdown: {result['class_breakdown']}\"\\)\nassert \"grass\" in result[\"class_breakdown\"]\nassert \"tree\" in result[\"class_breakdown\"]\nprint\\(\"PASS: class_breakdown correct!\"\\)\n\nfor f in [tmp, tmp2, tmp3]:\n    os.remove\\(f\\)\n\n# ===================================================================\n# TEST 2: WLK_IDX Calculator\n# ===================================================================\nprint\\(\"\\\\n\" + \"=\" * 60\\)\nprint\\(\"TEST 2: IND_WLK_IDX \\(Walkability Index\\)\"\\)\nprint\\(\"=\" * 60\\)\n\nwlk_globals = {\"semantic_colors\": semantic_colors, \"__name__\": \"test\"}\nexec\\(open\\(\"data/metrics_code/calculator_layer_IND_WLK_IDX.py\", encoding=\"utf-8\"\\).read\\(\\), wlk_globals\\)\n\ncalculate_wlk = wlk_globals[\"calculate_indicator\"]\nSIDEWALK_RGB = wlk_globals[\"SIDEWALK_RGB\"]\nDRIVEWAY_RGB = wlk_globals[\"DRIVEWAY_RGB\"]\n\nprint\\(f\"\\\\nSidewalk classes: {len\\(SIDEWALK_RGB\\)}, Driveway classes: {len\\(DRIVEWAY_RGB\\)}\"\\)\n\nsidewalk_rgb = semantic_colors[\"sidewalk;pavement\"]\nroad_rgb = semantic_colors[\"road;route\"]\n\n# Test: 40% sidewalk + 20% road = 66.67%\ntest_img4 = np.zeros\\(\\(100, 100, 3\\), dtype=np.uint8\\)\ntest_img4[0:40, 0:100] = sidewalk_rgb\ntest_img4[40:60, 0:100] = road_rgb\ntmp4 = os.path.join\\(tempfile.gettempdir\\(\\), \"test_wlk.png\"\\)\nImage.fromarray\\(test_img4\\).save\\(tmp4\\)\nr4 = calculate_wlk\\(tmp4\\)\nprint\\(f\"\\\\n40% sidewalk + 20% road => Expected: 66.667%, Got: {r4['value']}\"\\)\nassert r4[\"success\"] and r4[\"value\"] is not None and abs\\(r4[\"value\"] - 66.667\\) < 0.1\nprint\\(\"PASS!\"\\)\n\n# Only sidewalk => 100%\ntest_img5 = np.zeros\\(\\(100, 100, 3\\), dtype=np.uint8\\)\ntest_img5[0:50, 0:100] = sidewalk_rgb\ntmp5 = os.path.join\\(tempfile.gettempdir\\(\\), \"test_wlk2.png\"\\)\nImage.fromarray\\(test_img5\\).save\\(tmp5\\)\nr5 = calculate_wlk\\(tmp5\\)\nprint\\(f\"\\\\n50% sidewalk, 0% road => Expected: 100.0%, Got: {r5['value']}\"\\)\nassert r5[\"value\"] is not None and abs\\(r5[\"value\"] - 100.0\\) < 0.1\nprint\\(\"PASS!\"\\)\n\n# No sidewalk, no road => None\ntest_img6 = np.zeros\\(\\(100, 100, 3\\), dtype=np.uint8\\)\ntmp6 = os.path.join\\(tempfile.gettempdir\\(\\), \"test_wlk3.png\"\\)\nImage.fromarray\\(test_img6\\).save\\(tmp6\\)\nr6 = calculate_wlk\\(tmp6\\)\nprint\\(f\"\\\\nNo sidewalk, no road => Expected: None, Got: {r6['value']}\"\\)\nassert r6[\"value\"] is None\nprint\\(\"PASS!\"\\)\n\n# Only road => 0%\ntest_img7 = np.zeros\\(\\(100, 100, 3\\), dtype=np.uint8\\)\ntest_img7[0:50, 0:100] = road_rgb\ntmp7 = os.path.join\\(tempfile.gettempdir\\(\\), \"test_wlk4.png\"\\)\nImage.fromarray\\(test_img7\\).save\\(tmp7\\)\nr7 = calculate_wlk\\(tmp7\\)\nprint\\(f\"\\\\n0% sidewalk, 50% road => Expected: 0.0%, Got: {r7['value']}\"\\)\nassert r7[\"value\"] is not None and abs\\(r7[\"value\"] - 0.0\\) < 0.1\nprint\\(\"PASS!\"\\)\n\n# Class breakdown\nprint\\(f\"\\\\nClass breakdown: {r4['class_breakdown']}\"\\)\nassert \"sidewalk;pavement\" in r4[\"class_breakdown\"]\nassert \"road;route\" in r4[\"class_breakdown\"]\nprint\\(\"PASS: class_breakdown correct!\"\\)\n\nfor f in [tmp4, tmp5, tmp6, tmp7]:\n    os.remove\\(f\\)\n\n# ===================================================================\n# TEST 3: Test a few Library calculators \\(GVI, BVI, SVF\\)\n# ===================================================================\nprint\\(\"\\\\n\" + \"=\" * 60\\)\nprint\\(\"TEST 3: Library calculators \\(GVI, BVI, SVF\\)\"\\)\nprint\\(\"=\" * 60\\)\n\nfor calc_name in [\"IND_GVI\", \"IND_BVI\", \"IND_SVF\"]:\n    g = {\"semantic_colors\": semantic_colors, \"__name__\": \"test\"}\n    exec\\(open\\(f\"data/metrics_code/calculator_layer_{calc_name}.py\", encoding=\"utf-8\"\\).read\\(\\), g\\)\n    calc_fn = g[\"calculate_indicator\"]\n    indicator = g[\"INDICATOR\"]\n    target_rgb = g[\"TARGET_RGB\"]\n    \n    print\\(f\"\\\\n{indicator['id']}: {indicator['name']}\"\\)\n    print\\(f\"  calc_type={indicator['calc_type']}, matched_classes={len\\(target_rgb\\)}\"\\)\n    \n    # Create test image with some target class pixels\n    test_img = np.zeros\\(\\(100, 100, 3\\), dtype=np.uint8\\)\n    if target_rgb:\n        first_rgb = list\\(target_rgb.keys\\(\\)\\)[0]\n        first_name = target_rgb[first_rgb]\n        test_img[0:25, 0:100] = first_rgb  # 25% first class\n    \n    tmp = os.path.join\\(tempfile.gettempdir\\(\\), f\"test_{calc_name}.png\"\\)\n    Image.fromarray\\(test_img\\).save\\(tmp\\)\n    r = calc_fn\\(tmp\\)\n    print\\(f\"  Result: success={r['success']}, value={r['value']}\"\\)\n    assert r[\"success\"], f\"{calc_name} failed\"\n    if target_rgb:\n        assert abs\\(r[\"value\"] - 25.0\\) < 0.1, f\"{calc_name}: expected 25%, got {r['value']}\"\n        print\\(f\"  PASS! \\(25% {first_name}\\)\"\\)\n    os.remove\\(tmp\\)\n\n# ===================================================================\n# TEST 4: Non-file error handling\n# ===================================================================\nprint\\(\"\\\\n\" + \"=\" * 60\\)\nprint\\(\"TEST 4: Error handling\"\\)\nprint\\(\"=\" * 60\\)\n\nr_err = calculate_vpe\\(\"/nonexistent/image.png\"\\)\nprint\\(f\"Missing file: success={r_err['success']}, error={r_err.get\\('error', ''\\)[:50]}\"\\)\nassert not r_err[\"success\"]\nprint\\(\"PASS: Error handling works!\"\\)\n\nprint\\(\"\\\\n\" + \"=\" * 60\\)\nprint\\(\"ALL TESTS PASSED!\"\\)\nprint\\(\"=\" * 60\\)\nPYEOF)",
      "Bash(cd \"D:/green-svc/greensvc/packages/backend\" && PYTHONIOENCODING=utf-8 python << 'PYEOF'\nimport json, os, sys, io, glob, tempfile\nsys.stdout = io.TextIOWrapper\\(sys.stdout.buffer, encoding=\"utf-8\", errors=\"replace\"\\)\n\nimport numpy as np\nfrom PIL import Image\n\n# Load semantic config\nwith open\\(\"data/Semantic_configuration.json\", \"r\", encoding=\"utf-8\"\\) as f:\n    config = json.load\\(f\\)\nsemantic_colors = {}\nfor item in config:\n    hex_color = item[\"color\"].lstrip\\(\"#\"\\)\n    rgb = tuple\\(int\\(hex_color[i:i+2], 16\\) for i in \\(0, 2, 4\\)\\)\n    semantic_colors[item[\"name\"]] = rgb\n\n# Create a test image with multiple classes\ntest_img = np.zeros\\(\\(200, 200, 3\\), dtype=np.uint8\\)\ntest_img[0:40, :] = semantic_colors[\"tree\"]           # 20%\ntest_img[40:60, :] = semantic_colors[\"grass\"]          # 10%\ntest_img[60:80, :] = semantic_colors[\"building;edifice\"]  # 10%\ntest_img[80:100, :] = semantic_colors[\"sky\"]           # 10%\ntest_img[100:120, :] = semantic_colors[\"road;route\"]   # 10%\ntest_img[120:140, :] = semantic_colors[\"sidewalk;pavement\"]  # 10%\ntest_img[140:160, :] = semantic_colors[\"water\"]        # 10%\ntest_img[160:180, :] = semantic_colors[\"fence;fencing\"]  # 10%\ntest_img[180:200, :] = semantic_colors[\"wall\"]         # 10%\n\ntmp = os.path.join\\(tempfile.gettempdir\\(\\), \"test_multi.png\"\\)\nImage.fromarray\\(test_img\\).save\\(tmp\\)\n\nfiles = sorted\\(glob.glob\\(\"data/metrics_code/calculator_layer_*.py\"\\)\\)\npassed = 0\nfailed = 0\nerrors = []\n\nprint\\(f\"Testing all {len\\(files\\)} calculators with multi-class test image\\\\n\"\\)\n\nfor f in files:\n    basename = os.path.basename\\(f\\)\n    ind_name = basename.replace\\(\"calculator_layer_\", \"\"\\).replace\\(\".py\", \"\"\\)\n    \n    try:\n        g = {\"semantic_colors\": semantic_colors, \"__name__\": \"test\"}\n        exec\\(open\\(f, encoding=\"utf-8\"\\).read\\(\\), g\\)\n        \n        calc_fn = g.get\\(\"calculate_indicator\"\\)\n        indicator = g.get\\(\"INDICATOR\", {}\\)\n        \n        if calc_fn is None:\n            errors.append\\(f\"  {ind_name}: no calculate_indicator function\"\\)\n            failed += 1\n            continue\n        \n        result = calc_fn\\(tmp\\)\n        \n        if result[\"success\"]:\n            print\\(f\"  OK  {ind_name:<16} value={result['value']}\"\\)\n            passed += 1\n        else:\n            # Some calculators may legitimately return success=False for certain images\n            print\\(f\"  OK* {ind_name:<16} success=False \\(error: {result.get\\('error', 'N/A'\\)[:60]}\\)\"\\)\n            passed += 1  # Still counts as working if it handles the case\n            \n    except Exception as e:\n        err_str = str\\(e\\)[:80]\n        errors.append\\(f\"  {ind_name}: {err_str}\"\\)\n        failed += 1\n        print\\(f\"  FAIL {ind_name:<16} {err_str}\"\\)\n\nos.remove\\(tmp\\)\n\nprint\\(f\"\\\\n{'=' * 60}\"\\)\nprint\\(f\"RESULTS: {passed} passed, {failed} failed out of {len\\(files\\)}\"\\)\nif errors:\n    print\\(f\"\\\\nErrors:\"\\)\n    for e in errors:\n        print\\(e\\)\nprint\\(f\"{'=' * 60}\"\\)\nPYEOF)",
      "Bash(tail:*)",
      "Bash(cd \"D:/green-svc/greensvc/packages/backend\" && PYTHONIOENCODING=utf-8 timeout 15 python -c \"\nimport sys, io\nsys.stdout = io.TextIOWrapper\\(sys.stdout.buffer, encoding='utf-8', errors='replace'\\)\nsys.stderr = io.TextIOWrapper\\(sys.stderr.buffer, encoding='utf-8', errors='replace'\\)\n\n# Start the app and test via TestClient\nfrom fastapi.testclient import TestClient\nfrom app.main import create_app\n\napp = create_app\\(\\)\nclient = TestClient\\(app\\)\n\n# Test GET /api/metrics\nresp = client.get\\('/api/metrics'\\)\nprint\\(f'GET /api/metrics: status={resp.status_code}'\\)\ndata = resp.json\\(\\)\nprint\\(f'Calculators returned: {len\\(data\\)}'\\)\n\n# Show all IDs\nids = sorted\\([c['id'] for c in data]\\)\nprint\\(f'IDs: {ids}'\\)\n\n# Test specific endpoints\nfor ind_id in ['IND_VPE', 'IND_WLK_IDX', 'IND_GVI']:\n    r = client.get\\(f'/api/metrics/{ind_id}'\\)\n    d = r.json\\(\\)\n    print\\(f'GET /api/metrics/{ind_id}: {d[\\\\\"name\\\\\"]} \\(calc_type={d[\\\\\"calc_type\\\\\"]}\\)'\\)\n\n# Test code endpoint\nr = client.get\\('/api/metrics/IND_VPE/code'\\)\nprint\\(f'GET /api/metrics/IND_VPE/code: status={r.status_code}, has_code={\\\\\"calculate_indicator\\\\\" in r.json\\(\\).get\\(\\\\\"code\\\\\", \\\\\"\\\\\"\\)}'\\)\n\nprint\\(\\)\nprint\\('API TESTS PASSED!'\\)\n\" 2>&1)"
    ]
  }
}
